{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre> <ul> <li>w</li> <li> <p>w</p> </li> <li> <p>dsd</p> </li> <li> <p>fasd</p> </li> <li> <p> adfkasfafaf</p> </li> <li> adfkasfafaf</li> <li> adfkasfafaf</li> </ul> <p>Google</p> <p>jdsdjd</p> <p>jssjcsncjscnsc </p> jajaja kakaka adaskas oskdaad <p>tachado</p> <p>marcado</p>"},{"location":"scripts_python/check_comunicador/","title":"Check Comunicador","text":"<p>Script python para checagem e verifica\u00e7\u00e3o de atividade para o Software monitor e comunicador da SEFAZ</p>"},{"location":"scripts_python/check_comunicador/#o-problema","title":"O problema","text":"<p>Inicialmente tivemos um problema relacionado aos drives do MFE (M\u00f3dulo Fiscal Eletr\u00f4nico) onde o mesmo ficava constantemente offline devido a queda dos servi\u00e7os do comunicador e monitor, por\u00e9m, os mesmos ficavam up com a execu\u00e7\u00e3o manual via shell.</p> <p>O script do comunicador \u00e9 respons\u00e1vel por estabelecer a comunica\u00e7\u00e3o do o MFE e o script monitor \u00e9 respons\u00e1vel por retornar um status visual do estado do m\u00f3dulo, ou seja, se encontra-se conectado ou n\u00e3o ao computador.</p>"},{"location":"scripts_python/check_comunicador/#solucao","title":"Solu\u00e7\u00e3o","text":"<p>Como solu\u00e7\u00e3o, trouxe um script em python onde o mesmo teria duas vers\u00f5es visando a falta de padroniza\u00e7\u00e3o nos sistemas linux (como ubuntu 16.04 e 18.04, Zorin 14.04 e 16.04).</p> <p>Nesse artigo trataremos do script adaptado como Solu\u00e7\u00e3o para o python3.6.</p> <p>A solu\u00e7\u00e3o abordada foi o srcipt <code>check_comunicador.py</code>, que basicamente utiliza bibliotecas como threading, subprocess e time:</p> <ul> <li> <p>Threading: Utilizar threads possibilitou o a cria\u00e7\u00e3o de treads para ent\u00e3o   realizarmos a checagem de modo concorrente ao inserirmos na pool.</p> </li> <li> <p>Subprocess: A biblioteca subprocess \u00e9 utilizada para realizar processos   UNIX no python (como o up dos scripts que s\u00e3o feitos em shell).</p> </li> <li> <p>Time: Utilizada apenas para definir o time de rechecagem.</p> </li> </ul> check_comunicador.py<pre><code>import threading as t\nfrom subprocess import run, PIPE\nfrom time import sleep \n</code></pre> <p>Essa abordagem utiliza threads para execu\u00e7\u00e3o em paralelo visando a limita\u00e7\u00e3o do consumo de mem\u00f3ria ao impedir a cria\u00e7\u00e3o de processos \u00f3rf\u00e3os, visto que o mesmo seria executado via loop a cada dez segundos.</p>"},{"location":"scripts_python/check_comunicador/#analise-por-trecho-de-codigo","title":"An\u00e1lise por trecho de c\u00f3digo","text":"<p>De in\u00edcio temos a fun\u00e7\u00e3o <code>check_up()</code>que como o nome sugere, verifica se o script est\u00e1 up e retorna ou n\u00e3o o seu PID (N\u00famero do processo UNIX), caso o servi\u00e7o n\u00e3o esteja up o retorno \u00e9 uma string vazia.</p> <p>Outro ponto \u00e9 que essa fun\u00e7\u00e3o toma como par\u00e2metro apenas o servi\u00e7o <code>Comunicador</code> para verifica\u00e7\u00e3o de atividade. Essa medida foi tomada pois, as distros antigas est\u00e3o em processo de atualiza\u00e7\u00e3o, e tamb\u00e9m os erros dificilmente ocorrem com o servi\u00e7o do monitor (Ambas as verifica\u00e7\u00f5es s\u00e3o abordadas e realizadas no script <code>check_async.py</code>).</p> check_comunicador.py<pre><code>def check_up():\n\"\"\"\n    Fun\u00e7\u00e3o simples para coletar e retornar o PID do programa Comunicador.\n    \"\"\"\n\n    command = run(['ps -C Comunicador -o pid|grep -v PID'],\n                  shell=True,\n                  stdout=PIPE,\n                  universal_newlines=True)\n\n    return command.stdout.strip()\n</code></pre> <p>Como sequ\u00eancia temos a fun\u00e7\u00e3o <code>up</code> que de fato ir\u00e1 realizar o start dos programas repassados.</p> <p>De in\u00edcio temos duas constantes que ir\u00e3o armazenar a localiza\u00e7\u00e3o dos scripts: <code>COM</code> E <code>MON</code>.</p> <ul> <li>COM: Vari\u00e1vel com localiza\u00e7\u00e3o do script de start para o comunicador.</li> <li>MON: Vari\u00e1vel com localiza\u00e7\u00e3o do script de start para o Monitor.</li> </ul> check_comunicador.py<pre><code>COM = ['/usr/bin/nohup /opt/sefaz/cco/bin/runcco-ser.sh &gt; /dev/null 2&gt;&amp;1 &amp;']\nMON = ['/usr/bin/nohup /opt/sefaz/cco/bin/runcco-mon.sh &gt; /dev/null 2&gt;&amp;1 &amp;']\n</code></pre> <p>Em seguida veremos duas list comprehensions, onde a primeira far\u00e1 um for em cada objeto threading instanciado na vari\u00e1vel <code>threads</code> realizando assim um up na thread e por sua vez disponibilizando para a pool de processos e a segunda ir\u00e1 realizar um join em cada objeto threading, com isso o processo s\u00f3 ir\u00e1 avan\u00e7ar quando ambas as threads forem finalizadas. </p> check_comunicador.py<pre><code>def up():\n\"\"\"\n    Fun\u00e7\u00e3o que executa o script que chama o Comunicador em background e\n    redireciona sua sa\u00eddas para /dev/null quando executada atrav\u00e9s de uma thread\n    para limitar o consumo de mem\u00f3ria.\n    \"\"\"\n\n    COM = ['/usr/bin/nohup /opt/sefaz/cco/bin/runcco-ser.sh &gt; /dev/null 2&gt;&amp;1 &amp;']\n    MON = ['/usr/bin/nohup /opt/sefaz/cco/bin/runcco-mon.sh &gt; /dev/null 2&gt;&amp;1 &amp;']\n\n\n    threads = [\n        t.Thread(target=run(COM, shell=True), name='up'),\n        t.Thread(target=run(MON, shell=True), name='up')\n    ]\n\n    [th.start() for th in threads] \n    [th.join() for th in threads]\n</code></pre> <p>no <code>if __name__ == '__main__'</code> \u00e9 inserido um loop onde caso o servi\u00e7o n\u00e3o esteja rodando, a fun\u00e7\u00e3o <code>up()</code> ser\u00e1 chamada. O siclo se reinicia a cada 10 segundos (Isso ocorre visando a queda do servi\u00e7o na hora da emiss\u00e3o, ou seja, dez segundos \u00e9 tempo suficiente para cair e subir o servi\u00e7o antes do envio do cupom para a SEFAZ). </p> check_comunicador.py<pre><code>if __name__ == '__main__':\n\n    # O stdout do check_up(), ou seja, o output do run executado sempre ser\u00e1\n    # em string, se o comunicador n\u00e3o estiver em execu\u00e7\u00e3o o run() retornar\u00e1\n    # um string vazia, caso contr\u00e1rio o retorno ser\u00e1 uma string com o PID do\n    # processo.\n\n    # Loop que verifica se o Comunicador est\u00e1 UP\n    while True:\n        if not check_up():\n            up()\n\n        sleep(10)\n</code></pre>"},{"location":"scripts_python/check_comunicador/#codigo-completo","title":"C\u00f3digo completo","text":"check_comunicador.py<pre><code>#!/usr/bin/python3\n\nimport threading as t\nfrom subprocess import run, PIPE\nfrom time import sleep \n\n\ndef check_up():\n\"\"\"\n    Fun\u00e7\u00e3o simples para coletar e retornar o PID do programa Comunicador.\n    \"\"\"\n\n    command = run(['ps -C Comunicador -o pid|grep -v PID'],\n                  shell=True,\n                  stdout=PIPE,\n                  universal_newlines=True)\n\n    return command.stdout.strip()\n\n\ndef up():\n\"\"\"\n    Fun\u00e7\u00e3o que executa o script que chama o Comunicador em background e\n    redireciona sua sa\u00eddas para /dev/null quando executada atrav\u00e9s de uma thread\n    para limitar o consumo de mem\u00f3ria.\n    \"\"\"\n\n    COM = ['/usr/bin/nohup /opt/sefaz/cco/bin/runcco-ser.sh &gt; /dev/null 2&gt;&amp;1 &amp;']\n    MON = ['/usr/bin/nohup /opt/sefaz/cco/bin/runcco-mon.sh &gt; /dev/null 2&gt;&amp;1 &amp;']\n\n\n    threads = [\n        t.Thread(target=run(COM, shell=True), name='up'),\n        t.Thread(target=run(MON, shell=True), name='up')\n    ]\n\n    [th.start() for th in threads] \n    [th.join() for th in threads]\n\n\n\nif __name__ == '__main__':\n\n    # O stdout do check_up(), ou seja, o output do run executado sempre ser\u00e1\n    # em string, se o comunicador n\u00e3o estiver em execu\u00e7\u00e3o o run() retornar\u00e1\n    # um string vazia, caso contr\u00e1rio o retorno ser\u00e1 uma string com o PID do\n    # processo.\n\n    # Loop que verifica se o Comunicador est\u00e1 UP\n    while True:\n        if not check_up():\n            up()\n\n        sleep(10)\n</code></pre>"}]}