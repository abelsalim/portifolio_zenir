{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ol\u00e1... Bem vindo ao meu Portf\u00f3lio","text":"<p> Meu nome \u00e9 Abel Salim, tenho 23 anos e sou amante de tecnologia. Tenho mais afinidade com ferramentas linux como as vari\u00e1veis distros (Ubuntu, Debian, Archlinux, Manjaro, EndeavourOS e Gentoo), Raspberry e Shell Script. Ferramentas de versionamento de c\u00f3digos (git e github) tamb\u00e9m se encontram nesse leque de conhecimentos j\u00e1 adquiridos. Entretanto, esse portf\u00f3lio tem como objetivo acompanhar minha caminhada 'Rumo ao DEV', onde vou estar compartilhando minha caminhada e aprendizado em \u00e1reas de programa\u00e7\u00e3o python, contribui\u00e7\u00f5es em bibliotecas e outras ferramentas como banco de dados.</p>"},{"location":"#ultimos-posts","title":"\u00daltimos posts","text":"<p>{{ blog_content }}</p>"},{"location":"#estatisticas-do-github","title":"Estat\u00edsticas do GitHub","text":""},{"location":"#principais-repositorios","title":"Principais Reposit\u00f3rios","text":""},{"location":"blog/","title":"Blog","text":"<p>{{ blog_content }}</p>"},{"location":"blog/posts/funcoes_python/","title":"Fun\u00e7\u00f5es em Python","text":"<code>#fun\u00e7\u00f5es</code> <code>#python</code>","tags":["fun\u00e7\u00f5es","python"]},{"location":"blog/posts/funcoes_python/#funcoes-em-python","title":"Fun\u00e7\u00f5es em Python","text":"<p>Num \u00e2mbito geral, as fun\u00e7\u00f5es trouxeram para as linguagens de programa\u00e7\u00e3o a possibilidade da reutiliza\u00e7\u00e3o de trechos de c\u00f3digo em qualquer lugar do arquivo. Ap\u00f3s a ado\u00e7\u00e3o da parametriza\u00e7\u00e3o o resultado s\u00e3o c\u00f3digos limpos e de f\u00e1cil leitura.</p> <p>Em Python uma fun\u00e7\u00e3o \u00e9 definida pela palavra reservada <code>def</code> seguido do nome da fun\u00e7\u00e3o e entre par\u00eanteses os par\u00e2metros a serem atribu\u00eddos caso a fun\u00e7\u00e3o necessite dos mesmos.</p> <pre><code>def funcao(parametros):\n    print('Corpo da fun\u00e7\u00e3o')\n</code></pre> <p>def = Palavra especial;</p> <p>funcao = Nome da fun\u00e7\u00e3o;</p> <p>parametros = Par\u00e2metros da fun\u00e7\u00e3o;</p> <p>Tudo que estiver com a edenta\u00e7\u00e3o de quatro espa\u00e7os ap\u00f3s os dois pontos \u00e9 considerado como corpo da fun\u00e7\u00e3o, portanto ser\u00e1 executado quando o c\u00f3digo cham\u00e1-la.</p> <pre><code>def adicao(x, y):\n\"\"\"Fun\u00e7\u00e3o simples para soma de dois par\u00e2metros\"\"\"\n    return x + y\n\n\nprint(soma(1, 2))                      # Resultado = 03\n</code></pre> <p>O exemplo acima ilustra uma fun\u00e7\u00e3o que recebe dois par\u00e2metros e retorna a soma dos mesmos ao ser executado.</p> <p>Em fun\u00e7\u00f5es Python podemos passar quatro tipos de par\u00e2metros: normais , args, default, e *kwargs.</p>","tags":["fun\u00e7\u00f5es","python"]},{"location":"blog/posts/funcoes_python/#parametros-normais","title":"Par\u00e2metros normais","text":"<p>Assim como foi ilustrado anteriormente na fun\u00e7\u00e3o <code>adicao</code>, os par\u00e2metros normais s\u00e3o aqueles que simplesmente s\u00e3o chamados tornando a fun\u00e7\u00e3o dependente da entrada e ao mesmo tempo sujeita a um <code>TypeError</code> com a aus\u00eancia da mesma.</p> <pre><code>def adicao(x, y):\n\"\"\"Fun\u00e7\u00e3o simples para soma de dois par\u00e2metros\"\"\"\n    return x + y\n\n\nprint(soma(1, 2))                      # Resultado = 03\n</code></pre> <p>O exemplo abaixo ilustra a fun\u00e7\u00e3o <code>adicao</code> que deve receber dois par\u00e2metros de entrada, por\u00e9m retornou um <code>TypeError</code> ao ser executada com apenas um par\u00e2metro.</p> <pre><code>def adicao(x, y):\n\"\"\"Fun\u00e7\u00e3o simples para soma de dois par\u00e2metros\"\"\"\n    return x + y\n\n\nprint(soma(2))\n\n\"\"\"\nResultado:\n    \"TypeError: soma() missing 1 required positional argument: 'y'\"\n\"\"\"\n</code></pre>","tags":["fun\u00e7\u00f5es","python"]},{"location":"blog/posts/funcoes_python/#parametros-args","title":"Par\u00e2metros *args","text":"<p>Args \u00e9 um par\u00e2metro \u2018especial\u2019 que recebe os argumentos e os insere em uma tupla, e assim como as listas, tuplas podem ser iteradas tornando poss\u00edvel fazer m\u00faltiplas entradas sem necessariamente setar par\u00e2metro por par\u00e2metro na para a fun\u00e7\u00e3o.</p> <p>Antes de darmos in\u00edcio aos exemplos vamos deixar claro que a palavra args \u00e9 apenas uma conven\u00e7\u00e3o, ou seja, contanto que o asterisco venha primeiro, qualquer nome ou caractere ser\u00e1 aceito.</p>","tags":["fun\u00e7\u00f5es","python"]},{"location":"blog/posts/funcoes_python/#exemplo-1","title":"Exemplo 1","text":"<p>Um exemplo simples e pr\u00e1tico seria atribuirmos o args a fun\u00e7\u00e3o adicao para passarmos entradas m\u00faltiplas de argumentos e em seguida retornarmos a soma de todas as entradas.</p> <pre><code>def soma(*args):\n\"\"\"Fun\u00e7\u00e3o simples para soma de par\u00e2metros com *args\"\"\"\n    soma = sum(args)\n    return soma\n\n\nprint(soma(1))                         # Resultado = 01\nprint(soma(2, 3))                      # Resultado = 05\nprint(soma(3, 4, 5))                   # Resultado = 12\nprint(soma(4, 5, 6, 7))                # Resultado = 22\nprint(soma(5, 6, 7, 8, 9))             # Resultado = 35\n</code></pre> <p>Note que na fun\u00e7\u00e3o adicao foi realizada a soma e independente da quantidade de argumentos (1, 2, 3, 4, \u2026, 1000), ir\u00e1 ser realizado a soma dos valores ali inseridos.</p> <p>A fun\u00e7\u00e3o <code>sum()</code> tem a finalidade de retornar a soma de quaisquer valores que sejam inteiros ou float.</p>","tags":["fun\u00e7\u00f5es","python"]},{"location":"blog/posts/funcoes_python/#exemplo-2","title":"Exemplo 2","text":"<p>Para o nosso segundo exemplo, vamos imaginar que em uma loja de equipamentos eletr\u00f4nicos precisamos somar todos os valores recebidos a cada venda.</p> <p>Embora a fun\u00e7\u00e3o seja relativamente simples, vamos realizar esse recebimento de duas maneiras: soma em tempo real de execu\u00e7\u00e3o com a utiliza\u00e7\u00e3o de um for e utilizar a fun\u00e7\u00e3o <code>sum()</code>.</p> <p>Utilizando o for:</p> <pre><code>recebimentos = [1.2, 32.3, 40, 17.9, 137.37, 98, 47, 5, 2.5, 66]\n\n\ndef caixa(*args):\n\"\"\"Fun\u00e7\u00e3o simples para descompactar a lista recebimentos com *args\"\"\"\n    soma = 0\n    for x in args:\n        soma += x\n    return soma\n\n\nprint(caixa(*recebimentos))             # Resultado = 447.27\n</code></pre> <p>Utilizando <code>sum()</code>:</p> <pre><code>recebimentos = [1.2, 32.3, 40, 17.9, 137.37, 98, 47, 5, 2.5, 66]\n\n\ndef caixa(*args):\n\"\"\"Fun\u00e7\u00e3o simples para descompactar a lista recebimentos com *args\"\"\"\n    soma = sum(args)\n    return soma\n\n\nprint(caixa(*recebimentos))            # Resultado = 447.27\n</code></pre> <p>Note que com a fun\u00e7\u00e3o sum para realizar a soma dos valores o c\u00f3digo se torna mais \u2018enxuto\u2019, o que facilita uma futura leitura ou manuten\u00e7\u00e3o no c\u00f3digo.</p>","tags":["fun\u00e7\u00f5es","python"]},{"location":"blog/posts/funcoes_python/#parametros-default","title":"Par\u00e2metros default","text":"<p>Os par\u00e2metros com valor default servem para deixar opcional a sua entrada, tornando assim o c\u00f3digo mais male\u00e1vel.</p> <p>Voltando ao nosso exemplo da fun\u00e7\u00e3o adicao, podemos definir o valor padr\u00e3o para y e optar em passar ou n\u00e3o um argumento.</p> <pre><code>def adicao(x, y=10):\n\"\"\"Fun\u00e7\u00e3o simples para soma de dois par\u00e2metros\"\"\"\n    return x + y\n\n\nprint(soma(1))                         # Resultado = 11\nprint(soma(1, 2))                      # Resultado = 03\n</code></pre> <p>Nessa situa\u00e7\u00e3o, a fun\u00e7\u00e3o recebe como valor default para y o inteiro 10, ou seja, caso a entrada atribua um valor \u00e0 y, a fun\u00e7\u00e3o ir\u00e1 receber as suas entradas e fazer a soma com os respectivos valores para x e y, mas se esse n\u00e3o for o caso e apenas um valor tenha sido atribu\u00eddo, o par\u00e2metro y receber\u00e1 valor default 10 e a fun\u00e7\u00e3o n\u00e3o retornar\u00e1 um <code>TypeError</code>.</p>","tags":["fun\u00e7\u00f5es","python"]},{"location":"blog/posts/funcoes_python/#parametros-kwargs","title":"Par\u00e2metros **kwargs","text":"<p>Kwargs \u00e9 um par\u00e2metro \u2018especial\u2019 que recebe os argumentos como dicion\u00e1rio e assim como as listas ou tuplas, dicion\u00e1rios podem ser iterados tornando poss\u00edvel fazer m\u00faltiplas entradas sem necessariamente setar uma a uma na fun\u00e7\u00e3o.</p> <p>Antes de darmos in\u00edcio aos exemplos vamos deixar claro que a palavra kwargs \u00e9 apenas uma conven\u00e7\u00e3o, ou seja, contanto que os dois asteriscos venham primeiro, qualquer nome ou caractere ser\u00e1 aceito.</p>","tags":["fun\u00e7\u00f5es","python"]},{"location":"blog/posts/funcoes_python/#exemplo-1_1","title":"Exemplo 1","text":"<p>Para um exemplo simples e pr\u00e1tico vamos entrar com um kwargs que informa a cor favorita de algu\u00e9m:</p> <pre><code>def cor_favorita(**kwargs):\n    for nome, cor in kwargs.items():\n        print(f'A cor favorita de {nome.title()} \u00e9 {cor}')\n\n\ncor_favorita(salim='preto')\n\n\"\"\"\nResultado:\n    A cor favorita de Salim \u00e9 preto\n\"\"\"\n</code></pre> <p>Note que foi atribu\u00eddo a chave salim (nome do indiv\u00edduo) e o valor preto (cor favorita).</p> <p>Para essa fun\u00e7\u00e3o foi utilizada a fun\u00e7\u00e3o items que possibilita iterar em um dicion\u00e1rio atrav\u00e9s de um for explorando tanto chave quanto valores</p>","tags":["fun\u00e7\u00f5es","python"]},{"location":"blog/posts/funcoes_python/#exemplo-2_1","title":"Exemplo 2","text":"<p>Para ilustrarmos o exemplo vamos fazer uma fun\u00e7\u00e3o que receba um dicion\u00e1rio contendo como chave o nome de uma pessoa e como valor sua cor favorita, e imprima uma frase informando a quem pertence a cor favorita.</p> <pre><code>dicionario = {\n    'salim': 'preto',\n    'gigi': 'branco',\n    'edson': 'vermelho',\n    'rosy': 'rosa',\n    'lucas': 'azul',\n    'samuel': 'verde'\n}\n\n\ndef cor_favorita(**kwargs):\n    for nome, cor in kwargs.items():\n        print(f'A cor favorita de {nome.title()} \u00e9 {cor}')\n\n\ncor_favorita(**dicionario)\n\n\"\"\"\nResultado:\n    A cor favorita de Salim \u00e9 preto\n    A cor favorita de Gigi \u00e9 branco\n    A cor favorita de Edson \u00e9 vermelho\n    A cor favorita de Rosy \u00e9 rosa\n    A cor favorita de Lucas \u00e9 azul\n    A cor favorita de Samuel \u00e9 verde\n\"\"\"\n</code></pre> <p>Para essa fun\u00e7\u00e3o foi utilizada a fun\u00e7\u00e3o title que transforma a primeira de cada palavra de uma string em mai\u00fascula.</p>","tags":["fun\u00e7\u00f5es","python"]},{"location":"blog/posts/funcoes_python/#ordem","title":"Ordem","text":"<p>Em Python os par\u00e2metros de fun\u00e7\u00e3o seguem a ordem \u2018normais, default, args e *kwargs\u2019, caso anexe um tipo de par\u00e2metro antes ou ap\u00f3s da sua ordem definida o resultado vai ocorrer, mas n\u00e3o como esperado!</p> <p>Um exemplo para entendermos a import\u00e2ncia da ordem dos par\u00e2metros em uma fun\u00e7\u00e3o pode ser exemplificada a seguir:</p> <pre><code>lista_args = [1, 2, 4]\n\n\ndef exemplo(a, b, *args, linguagem='Python', **kwargs):\n    return [a, b, args, linguagem, kwargs]\n\n\nprint(exemplo(1, 2, *lista_args))\nprint(exemplo(1, 2, linguagem='JavaScript', nome='Abel'))\nprint(exemplo(1, 2, *lista_args, nome='Abel', sobrenome='Salim'))\n\n\"\"\"\nResultados\n    [1, 2, (1, 2, 4), 'Python', {}]\n    [1, 2, (), 'JavaScript', {'nome': 'Abel'}]\n    [1, 2, (1, 2, 4), 'Python', {'nome': 'Abel', 'sobrenome': 'Salim'}]\n\"\"\"\n</code></pre> <p>Na fun\u00e7\u00e3o <code>exemplo</code> demos entradas com dois par\u00e2metros normais (a, b), args (desempacotando a lista \u2018lista_args\u2019), default (linguagem=\u2019Python\u2019) e Kwargs.</p> <p>Nesse tipo de fun\u00e7\u00e3o temos que passar com obriga\u00e7\u00e3o apenas os par\u00e2metros normas (\u2018a\u2019 e \u2018b\u2019 que receberam respectivamente os valores de 1 e 2) e os demais s\u00e3o opcionais, onde args e kwargs retornam respectivamente uma tupla e dicion\u00e1rio vazias.</p> <p>Caso a ordem (normal, args, default, kwargs) n\u00e3o seja respeitada, um dos problemas que podemos ter ser\u00e1 o exemplificado a seguir:</p> <pre><code>lista_args = [1, 2, 4]\n\n\ndef exemplo(a, b, linguagem='Python', *args, **kwargs):\n    return [a, b, linguagem, args, kwargs]\n\n\nprint(exemplo(1, 2, linguagem='JavaScript', nome='Abel'))\nprint(exemplo(1, 2, *lista_args, nome='Abel', sobrenome='Salim'))\n\n\"\"\"\nResultados\n    [1, 2, 'JavaScript', (), {'nome': 'Abel'}]\n    [1, 2, 1, (2, 4), {'nome': 'Abel', 'sobrenome': 'Salim'}]\n\"\"\"\n</code></pre> <p>Ao executarmos essa fun\u00e7\u00e3o que solicita os par\u00e2metros fora de ordem temos sim um retorno, mas totalmente diferente do que esperamos.</p> <p>No primeiro print foi atribu\u00eddo os seguintes valores:</p> <pre><code>a = 1\nb = 2\nargs = ()\ndefault = \u2018JavaScript\u2019\nkwargs = \u201c nome=\u2019Abel\u2019 \u201d\n</code></pre> <p>E esperado o seguinte retorno:</p> <pre><code>[1, 2, (), \u2018JavaScript\u2019, {\u2018nome\u2019: \u2018Abel\u2019}]\n</code></pre> <p>Mas com a altera\u00e7\u00e3o da ordem dos par\u00e2metros tivemos o seguinte retorno:</p> <pre><code>a = 1\nb = 2\nargs = \u2018JavaScript\u2019\ndefault = ()\nkwargs = \u201c nome=\u2019Abel\u2019 \u201d\n</code></pre> <p>Ou seja, ao alterarmos a sequencia dos par\u00e2metros em python n\u00e3o temos um retorno de algum erro da linguagem, mas como as sa\u00eddas de args e default foram alteradas, essa modifica\u00e7\u00e3o retorna uma sa\u00edda inv\u00e1lida ao que a fun\u00e7\u00e3o foi destinada a realizar.</p>","tags":["fun\u00e7\u00f5es","python"]},{"location":"blog/posts/funcoes_python/#conclusao","title":"Conclus\u00e3o","text":"<p>Essa foi uma de v\u00e1rias explica\u00e7\u00f5es sobre fun\u00e7\u00f5es que voc\u00ea vai achar na internet, mas sinceramente, espero que tenha ajudado!</p>","tags":["fun\u00e7\u00f5es","python"]},{"location":"blog/posts/list_comprehension/","title":"List Comprehension em Python","text":"<code>#fun\u00e7\u00f5es</code> <code>#list comprehension</code> <code>#python</code>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"blog/posts/list_comprehension/#list-comprehension-em-python","title":"List Comprehension em Python","text":"<p>As compress\u00f5es s\u00e3o formas \u00e1geis e eficazes para gerar listas de maneira concisa, e embora a utiliza\u00e7\u00e3o de loop com ou sem opera\u00e7\u00f5es condicionais fa\u00e7am a mesma coisa, um list comprehension pode proporcionar uma economia consider\u00e1vel no consumo de mem\u00f3ria e linhas codadas.</p>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"blog/posts/list_comprehension/#estruturas-de-repeticao-e-list-comprehensions","title":"Estruturas de Repeti\u00e7\u00e3o e List Comprehensions","text":"<p>Uma grande d\u00favida sobre compress\u00f5es seria quando e porque us\u00e1-la, afinal as estruturas de repeti\u00e7\u00f5es s\u00e3o amplamente conhecidas e relativamente mais simples. Ent\u00e3o porque us\u00e1-la?</p> <ul> <li> <p>Codagem: Compress\u00f5es s\u00e3o geralmente mais compactas que fun\u00e7\u00f5es ou loops, proporcionando uma economia substancial em linhas codadas.</p> </li> <li> <p>Depura\u00e7\u00e3o: Se utilizada corretamente, a forma compacta das compress\u00f5es facilita a leitura de depura\u00e7\u00e3o do c\u00f3digo.</p> </li> </ul>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"blog/posts/list_comprehension/#sintaxe","title":"Sintaxe","text":"<p>Antes de qualquer coisa vamos entender sua sintaxe.</p> <pre><code>[dado for dado in iter\u00e1vel]\n</code></pre> <p>Um list comprehension sempre ser\u00e1 executado dentro de colchetes (assim como uma lista) e o <code>return</code> ser\u00e1 impl\u00edcito.</p> <p>Para ilustrarmos as diferen\u00e7as entre as funcionalidades, vamos explanar sobre loops e compress\u00f5es individualmente.</p> <p>Em nosso exemplo vamos receber um iter\u00e1vel e retornar seu quadrado.</p>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"blog/posts/list_comprehension/#utilizando-estrutura-de-repeticao-for","title":"Utilizando estrutura de repeti\u00e7\u00e3o For","text":"<pre><code>numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nquadrado = []\n\nfor numero in numeros:\n    quadrado.append(numero ** 2)\n\nprint(quadrado)         # Resultado = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n</code></pre> <p>Para esse c\u00f3digo criamos uma lista com numerais para iterar no <code>for</code> e tamb\u00e9m uma outra lista (quadrado) para inserirmos o quadrado de cada n\u00famero da lista <code>numeros</code>.</p> <p>Em seguida um <code>for</code> se encarregou de iterar na lista <code>numeros</code> e a cada rodada do <code>for</code> foi inserido o quadrado de cada n\u00famero na lista <code>quadrado</code>.</p>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"blog/posts/list_comprehension/#utilizando-list-comprehension","title":"Utilizando List Comprehension","text":"<pre><code>numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nquadrado = [numero ** 2 for numero in numeros]\n\nprint(quadrado)         # Resultado = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n</code></pre> <p>Para esse c\u00f3digo criamos uma lista com numerais, e na lista quadrado cont\u00e9m um comprehension onde um for ir\u00e1 iterar no iter\u00e1vel <code>numeros</code> atrav\u00e9s da vari\u00e1vel  numero atribu\u00edda no for, e retorna justamente o quadrado da vari\u00e1vel da rodada (vari\u00e1vel numero), ou seja, o retorno ser\u00e1 o quadrado de cada n\u00famero iterado.</p>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"blog/posts/list_comprehension/#aplicando-logica-condicional-as-compressoes","title":"Aplicando L\u00f3gica Condicional as Compress\u00f5es","text":"<p>As estruturas condicionais (if e else) podem ser adicionadas \u00e0s compress\u00f5es com pouco esfor\u00e7o, basta entender a sintaxe.</p>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"blog/posts/list_comprehension/#uma-condicional","title":"Uma condicional","text":"<p>Nas compress\u00f5es podemos utilizar uma condicional apenas, caso essa seja a necessidade. A seguir veremos uma breve sintaxe/escopo da compress\u00e3o.</p> <pre><code>[dado for dado in iter\u00e1vel if condicao]\n</code></pre> <p>Agora veremos breves exemplos de sua utiliza\u00e7\u00e3o juntamente com loops para fins comparacionais.</p>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"blog/posts/list_comprehension/#utilizando-estrutura-de-repeticao-for_1","title":"Utilizando estrutura de repeti\u00e7\u00e3o For","text":"<p>Separando os n\u00fameros \u00edmpares de uma lista em uma nova lista.</p> <pre><code>numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnumeros_impares = []\n\nfor numero in numeros:\n    if numero % 2:\n        numeros_impares.append(x)\n\nprint(numeros_impares)  # Resultado = [1, 3, 5, 7, 9]\n</code></pre> <p>No exemplo acima criamos uma lista com os n\u00fameros de 1 a 10, e outra vazias para inserirmos os n\u00fameros \u00edmpares ap\u00f3s fazermos o filtro com o <code>for</code>.</p> <p>Para realizar a separa\u00e7\u00e3o/descoberta dos n\u00fameros \u00edmpares em um conjunto maior temos que dividi-los por 2, sendo que se o resto da divis\u00e3o for 1, significa que o dividendo \u00e9 \u00edmpar, sen\u00e3o o dividendo ser\u00e1 par.</p> <p>Felizmente podemos utilizar o operador <code>%</code> que realiza a divis\u00e3o dos n\u00fameros repassados e retorna o resto dessa divis\u00e3o.</p> <p>Por fim, ao 'printarmos' as listas <code>numeros_impares</code> ser\u00e1 retornado os n\u00fameros \u00edmpares contidos na lista <code>numeros</code>.</p>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"blog/posts/list_comprehension/#utilizando-list-comprehension_1","title":"Utilizando List Comprehension","text":"<p>Separando os n\u00fameros \u00edmpares de uma lista em uma nova lista.</p> <pre><code>numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nnumeros_impares = [numero for numero in numeros if numero % 2]\n\nprint(numeros_impares)  # Resultado = [1, 3, 5, 7, 9]\n</code></pre> <p>No exemplo acima criamos uma lista com os n\u00fameros de 1 a 10 e uma outra (numeros_impares) que recebeu diretamente a list comprehension, pois as compress\u00f5es retornam o que for executado a cada <code>for</code>, ou seja, os n\u00famero da lista ao quadrado.</p> <p>Nesse caso o c\u00f3digo com for levou cerca de 06 linhas para ser codada, j\u00e1 o c\u00f3digo com list comprehension levou apenas 03 linhas.</p>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"blog/posts/list_comprehension/#dupla-condicional","title":"Dupla Condicional","text":"<p>Nas compress\u00f5es podemos utilizar dupla condicionais como <code>if</code> e <code>else</code>. A seguir veremos uma breve sintaxe/escopo da compress\u00e3o.</p> <pre><code>[x.append(dado) if codicao else y.append(dado) for dado in iter\u00e1vel]\n</code></pre> <p>Sabendo como seria sua utiliza\u00e7\u00e3o agora vamos colocar a m\u00e3o na massa e realizar alguns exemplos.</p>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"blog/posts/list_comprehension/#utilizando-estrutura-de-repeticao-for_2","title":"Utilizando estrutura de repeti\u00e7\u00e3o For","text":"<p>Separando os n\u00fameros \u00edmpares e pares de uma lista em duas novas listas.</p> <pre><code>numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nnumeros_impares = []\nnumeros_pares = []\n\nfor numero in numeros:\n    if numero % 2:\n        numeros_impares.append(x)\n    else:\n        numeros_pares.append(x)\n\nprint(numeros_impares)  # Resultado = [1, 3, 5, 7, 9]\nprint(numeros_pares)    # Resultado = [2, 4, 6, 8, 10]\n</code></pre> <p>No exemplo acima criamos uma lista com os n\u00fameros de 1 a 10, e duas listas vazias para inserirmos os n\u00fameros \u00edmpares e pares ap\u00f3s fazermos o filtro com o <code>for</code>.</p> <p>Para realizar a separa\u00e7\u00e3o/descoberta dos n\u00fameros \u00edmpares em um conjunto maior, temos que dividi-los por 2, sendo que se o resto da divis\u00e3o for 1, significa que o dividendo \u00e9 \u00edmpar, sen\u00e3o o dividendo ser\u00e1 par.</p> <p>Felizmente podemos utilizar o operador % que realiza a divis\u00e3o dos n\u00fameros repassados e retorna o resto dessa divis\u00e3o.</p> <p>Por fim, ao printarmos as listas <code>numeros_impares</code> e <code>numeros_pares</code> ser\u00e1 retornado respectivamente os n\u00fameros \u00edmpares e pares contidos na lista <code>numeros</code>.</p>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"blog/posts/list_comprehension/#utilizando-list-comprehension_2","title":"Utilizando List Comprehension","text":"<p>Separando os n\u00fameros \u00edmpares e pares de uma lista em duas novas listas.</p> <p>Nesse tipo de c\u00f3digo podemos optar em usar apenas uma condicional e criarmos ambas as listas recebendo o retorno das compress\u00f5es ou criar duas listas (numeros_impares e numeros_pares) previamente ou num s\u00f3 comprehension direcionar os n\u00fameros para as listas.</p>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"blog/posts/list_comprehension/#exemplo-1","title":"Exemplo 1","text":"<pre><code>numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nnumeros_impares = [numero for numero in numeros if numero % 2]\nnumeros_pares = [numero for numero in numeros if not numero % 2]\n\nprint(numeros_impares)  # Resultado = [1, 3, 5, 7, 9]\nprint(numeros_pares)    # Resultado = [2, 4, 6, 8, 10]\n</code></pre> <p>No exemplo acima criamos uma lista com os n\u00fameros de 1 a 10. J\u00e1 as listas receberam diretamente as list comprehension, pois as compress\u00f5es retornam o que for executado a cada for, ou seja, os n\u00famero \u00edmpares ou pares.</p> <p>Nesse caso o c\u00f3digo com for levou cerca de 10 linhas para ser codada, j\u00e1 o c\u00f3digo com list comprehension levou apenas 05 linhas.</p>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"blog/posts/list_comprehension/#exemplo-2","title":"Exemplo 2","text":"<pre><code>numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nnumeros_impares = []\nnumeros_pares = []\n\n[numeros_impares.append(num) if num % 2 else numeros_pares.append(num) for num in numeros]\n\nprint(numeros_impares)                # Resultado = [1, 3, 5, 7, 9]\nprint(numeros_pares)                  # Resultado = [2, 4, 6, 8, 10]\n</code></pre> <p>Nesse exemplo criamos as duas listas previamente e em seguida realizamos a atribui\u00e7\u00e3o dos n\u00fameros pares a lista <code>numeros_pares</code> e impares a lista <code>numeros_impares</code> com uma s\u00f3 compress\u00e3o.</p> <p>Nesse momento deve imaginar que o exemplo 2 \u00e9 maior, mau organizado e talvez at\u00e9 mais complexo, ent\u00e3o porque usar o exemplo 2 e n\u00e3o o 1? A resposta \u00e9 simples, consumo de mem\u00f3ria!</p> <p>Isso mesmo, o segundo exemplo traz uma economia em espa\u00e7o alocado em mem\u00f3ria, mas obviamente essa economia se torna percept\u00edvel em c\u00f3digos grandes e quase impercept\u00edveis em pequenos scripts, isso porque pequenos scripts s\u00e3o geralmente feitos para executarem uma a\u00e7\u00e3o e finalizarem o processo.</p> <p>Para analisarmos essa diferen\u00e7a de consumo vamos utilizar do pacote <code>getsizeof</code> do m\u00f3dulo <code>sys</code> que tem como inteira e \u00fanica finalidade retornar o consumo de um objeto/fun\u00e7\u00e3o/comprehension/generator/etc em bytes.</p> <p>Para importarmos o pacote <code>sys</code> faremos um <code>from sys import getsizeof</code> e para termos o retorno do consumo, colocaremos o trecho a ser avaliado como par\u00e2metro da fun\u00e7\u00e3o <code>getsizeof()</code>.</p>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"blog/posts/list_comprehension/#exemplo-1-getsizeof","title":"Exemplo 1 - getsizeof","text":"<pre><code>from sys import getsizeof\n\nnumeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nprint(getsizeof([numero for numero in numeros if numero % 2]))\nprint(getsizeof([numero for numero in numeros if not numero % 2]))\n\n# Resultado do 01\u00ba print = 120\n# Resultado do 02\u00ba print = 120\n</code></pre>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"blog/posts/list_comprehension/#exemplo-2-getsizeof","title":"Exemplo 2 - getsizeof","text":"<pre><code>from sys import getsizeof\n\nnumeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nnumeros_impares = []\nnumeros_pares = []\n\nprint(getsizeof([numeros_impares.append(num) if num % 2 else numeros_pares.append(num) for num in numeros]))\n\n# Resultado = 184\n</code></pre> <p>Como podemos ver nas sa\u00eddas retornadas, o primeiro c\u00f3digo embora mais bem estruturado ou de f\u00e1cil interpreta\u00e7\u00e3o (opini\u00e3o do autor), cada compress\u00e3o consome cerca de 120 bytes, ou seja, um consumo final de 240 bytes, j\u00e1 com o segundo exemplo consumiu apenas 184 bytes. Nesse momento voc\u00ea deve ter se perguntado o que \u00e9 56 bytes para o n\u00edvel de tecnologia atual que temos hoje, bom, tudo vai depender da finalidade do seu c\u00f3digo!</p> <p>Para sistemas complexos de gest\u00e3o empresarial, a l\u00f3gica e a forma de como foi aplicada \u00e9 vital, pois nesse cen\u00e1rio, tempo de execu\u00e7\u00e3o \u00e9 literalmente dinheiro.</p> <p>Em scripts de execu\u00e7\u00e3o r\u00e1pida que apenas verificam par\u00e2metros, status ou fun\u00e7\u00f5es simples, eu iria com um c\u00f3digo mais \u2018bonito\u2019 ou de f\u00e1cil interpreta\u00e7\u00e3o.  </p>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"blog/posts/list_comprehension/#apenas-estruturas-condicionais","title":"Apenas Estruturas Condicionais","text":"<p>Nas compress\u00f5es podemos utilizar dupla condicionais como <code>if</code> e <code>else</code> sem utilizar o <code>for</code>. A seguir veremos uma breve sintaxe/escopo da compress\u00e3o.</p> <pre><code>[x.append(dado) if codicao else y.append(dado)]\n</code></pre> <p>Por n\u00e3o termos um for para iterar podemos utilizar um list comprehension para valida\u00e7\u00e3o de par\u00e2metros em fun\u00e7\u00f5es ou m\u00e9todos de objetos.</p> <p>Nesse t\u00f3pico vamos criar uma lista chamada <code>numeros</code> que ir\u00e1 conter n\u00fameros iniciados em 1, terminados em 1000, num passo de 3 d\u00edgitos, ou seja, a lista ter\u00e1 a seguinte composi\u00e7\u00e3o: 1, 4, 7, 10, 13, 16, 19, 22, 25, \u2026, 1000.</p> <p>Sabendo como ser\u00e1 sua utiliza\u00e7\u00e3o agora vamos colocar a m\u00e3o na massa e realizar alguns exemplos.</p>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"blog/posts/list_comprehension/#utilizando-estrutura-de-repeticao-for_3","title":"Utilizando estrutura de repeti\u00e7\u00e3o For","text":"<pre><code>numeros = list(range(1, 1001, 3))\n\n\ndef verifica(numero):\n    if numero in numeros:\n        print(f'{numero} est\u00e1 na lista numeros')\n    else:\n        print(f'{numero} n\u00e3o est\u00e1 na lista numeros')\n\n\nverifica(int(input('Informe um n\u00famero: ')))\n</code></pre>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"blog/posts/list_comprehension/#utilizando-list-comprehension_3","title":"Utilizando List Comprehension","text":"<pre><code>numeros = list(range(1, 1001, 3))\n\n\ndef verifica(numero):\n    [print(f'{numero} est\u00e1 na lista numeros') if numero in numeros else print(f'{numero} n\u00e3o est\u00e1 na lista numeros')]\n\n\nverifica(int(input('Informe um n\u00famero: ')))\n</code></pre> <p>Embora escritos de formas diferentes, ambos os trechos t\u00eam a mesma finalidade! Ap\u00f3s a cria\u00e7\u00e3o da lista com range, verificamos se dado n\u00famero chamado com o input contido na execu\u00e7\u00e3o da fun\u00e7\u00e3o <code>verifica</code> se faz presente na lista <code>numeros</code>.</p>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"blog/posts/list_comprehension/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesse artigo vimos a import\u00e2ncia das compress\u00f5es no meio do c\u00f3digo e o poder que elas tem nos quesitos de funcionalidade, agilidade, c\u00f3digo limpo e economia em mem\u00f3ria. Espero que tenha ajudado! </p>","tags":["fun\u00e7\u00f5es","list comprehension","python"]},{"location":"scripts_python/check_async/","title":"Check Async","text":"<p>Script python para checagem e verifica\u00e7\u00e3o de atividade para o Software monitor e comunicador da SEFAZ</p>"},{"location":"scripts_python/check_async/#o-problema","title":"O problema","text":"<p>Inicialmente tivemos um problema relacionado aos drives do MFE (M\u00f3dulo Fiscal Eletr\u00f4nico) onde o mesmo ficava constantemente offline devido a queda dos servi\u00e7os do comunicador e monitor, por\u00e9m, os mesmos ficavam up com a execu\u00e7\u00e3o manual via shell.</p> <p>O script do comunicador \u00e9 respons\u00e1vel por estabelecer a comunica\u00e7\u00e3o do o MFE e o script monitor \u00e9 respons\u00e1vel por retornar um status visual do estado do m\u00f3dulo, ou seja, se encontra-se conectado ou n\u00e3o ao computador.</p>"},{"location":"scripts_python/check_async/#solucao","title":"Solu\u00e7\u00e3o","text":"<p>Como solu\u00e7\u00e3o, trouxe um script em python onde o mesmo teria duas vers\u00f5es visando a falta de padroniza\u00e7\u00e3o nos sistemas linux (como ubuntu 16.04 e 18.04, Zorin 14.04 e 16.04).</p> <p>Nesse artigo trataremos do script adaptado como Solu\u00e7\u00e3o para o python3.9+.</p> <p>A solu\u00e7\u00e3o abordada foi o script <code>check_async.py</code>, que basicamente utiliza bibliotecas como <code>subprocess</code>, <code>asyncio</code> e <code>psutil</code>:</p> <ul> <li> <p>Subprocess: A biblioteca subprocess \u00e9 utilizada para realizar processos   UNIX no python (como o up dos scripts que s\u00e3o feitos em shell).</p> </li> <li> <p>AsyncIO: \u00c9 uma biblioteca utilizada para proporcionar o processamento ass\u00edncrono, com threads e de forma concorrente. </p> </li> <li> <p>Psutil: Utilizada para verificar se o processo est\u00e1 rodando.</p> </li> </ul> check_async.py<pre><code>import subprocess\nfrom asyncio import run, sleep, gather, to_thread\nfrom psutil import process_iter\n</code></pre> <p>Essa abordagem utiliza uma programa\u00e7\u00e3o ass\u00edncrona atrav\u00e9s da biblioteca asyncio e com seus recursos tornou mais eficaz a utiliza\u00e7\u00e3o de threads distintas sendo lan\u00e7adas na pool de processos de forma concorrente e n\u00e3o sequencial.</p>"},{"location":"scripts_python/check_async/#analise-por-trecho-de-codigo-arquivo-de-constantes","title":"An\u00e1lise por trecho de c\u00f3digo - Arquivo de Constantes","text":"<p>O arquivo de constantes \u00e9 composto por duas vari\u00e1veis do tipo <code>dict</code>, onde a chave \u00e9 o nome do processo ao qual usaremos para rastrear a atividade do mesmo e o valor \u00e9 comando de execu\u00e7\u00e3o utilizado para iniciar o processo.</p> constant.py<pre><code>COMUNICADOR = {\n    'Comunicador': \n    '/usr/bin/nohup /opt/sefaz/cco/bin/runcco-ser.sh &gt; /dev/null 2&gt;&amp;1 &amp;'\n    }\n\nMONITOR = {\n    'Monitor':\n    '/usr/bin/nohup /opt/sefaz/cco/bin/runcco-mon.sh &gt; /dev/null 2&gt;&amp;1 &amp;'\n    }\n</code></pre> <p>A express\u00e3o <code>&gt;</code> serve para direcionar o retorno do script executado para o destino <code>/dev/null 2&gt;&amp;1 &amp;</code>, onde o mesmo ser\u00e1 um destino nulo no sistema.</p>"},{"location":"scripts_python/check_async/#analise-por-trecho-de-codigo-arquivo-check-async","title":"An\u00e1lise por trecho de c\u00f3digo - Arquivo Check Async","text":"<p>De in\u00edcio temos a fun\u00e7\u00e3o <code>up_down()</code> que como o nome sugere, verifica se o script est\u00e1 ativo ou n\u00e3o. Para simplificar, iremos iterar em todos os processos  rodando no sistema atrav\u00e9s da biblioteca <code>psutil</code> e filtrar pelo nome dos  processo atrav\u00e9s da seguinte express\u00e3o: <code>process_iter(['name'])</code>. Mas  antes  disso vamos instanciar as constantes e desempacota-las nas vari\u00e1veis <code>key</code>  e <code>values</code> pela express\u00e3o <code>for key, value in process.items():</code>.</p> check_async.py<pre><code>def up_down(process):\n\"\"\"\n    Fun\u00e7\u00e3o respons\u00e1vel por identificar se o processo em palta est\u00e1 em execu\u00e7\u00e3o.\n    \"\"\"\nfor key, value in process.items():\nfor processo in process_iter(['name']):\n            if processo.info['name'] == key:\n                return True\n        subprocess.run(value, shell=True)\n</code></pre> <p>Agora foi adicionado um segundo <code>for</code> para enfim podermos iterar em cada processo com a biblioteca <code>psutil</code>. Para isso utilizamos a seguinte express\u00e3o <code>for processo in process_iter(['name']):</code>.</p> check_async.py<pre><code>def up_down(process):\n\"\"\"\n    Fun\u00e7\u00e3o respons\u00e1vel por identificar se o processo em palta est\u00e1 em execu\u00e7\u00e3o.\n    \"\"\"\n    for key, value in process.items():\nfor processo in process_iter(['name']):\nif processo.info['name'] == key:\n                return True\n        subprocess.run(value, shell=True)\n</code></pre> <p>Ap\u00f3s o desempacotamento das constantes e processos, \u00e9 necess\u00e1rio apenas criar uma condicional que se encarregue de verificar se ambos os nomes  de processos (chave da constante e nome do processo extra\u00eddo com <code>psutil</code>) s\u00e3o iguais.</p> check_async.py<pre><code>def up_down(process):\n\"\"\"\n    Fun\u00e7\u00e3o respons\u00e1vel por identificar se o processo em palta est\u00e1 em execu\u00e7\u00e3o.\n    \"\"\"\n    for key, value in process.items():\n        for processo in process_iter(['name']):\nif processo.info['name'] == key:\nreturn True\nsubprocess.run(value, shell=True)\n</code></pre> <p>Caso passe na condicional, o script estar\u00e1 em execu\u00e7\u00e3o,  mas se esse n\u00e3o for o  caso, ent\u00e3o o mesmo ser\u00e1 iniciado pelo <code>subprocess</code> que ir\u00e1 utilizar como  par\u00e2metro a vari\u00e1vel <code>value</code>para iniciar o processo em an\u00e1lise.</p> check_async.py<pre><code>def up_down(process):\n\"\"\"\n    Fun\u00e7\u00e3o respons\u00e1vel por identificar se o processo em palta est\u00e1 em execu\u00e7\u00e3o.\n    \"\"\"\n    for key, value in process.items():\n        for processo in process_iter(['name']):\n            if processo.info['name'] == key:\n                return True\nsubprocess.run(value, shell=True)\n</code></pre> <p>Em seguida veremos a fun\u00e7\u00e3o <code>main()</code>, que tem como finalidade utilizar a  biblioteca AsyncIO para executar a cada 10 segundos duas threads de forma  concorrente e ap\u00f3s uma an\u00e1lise individual realizar o start do script caso seja necess\u00e1rio. </p> check_async.py<pre><code>async def main():\n\"\"\"\n    Fun\u00e7\u00e3o principal que executa as verifica\u00e7\u00f5es/execu\u00e7\u00f5es como concorr\u00eancias.\n    \"\"\"\n    while True:\nawait gather(\nto_thread(up_down, MONITOR),\nto_thread(up_down, COMUNICADOR)\n)\nawait sleep(10)\n</code></pre> <p>Defini\u00e7\u00e3o dos termos abordados:</p> <ul> <li><code>async def</code>: express\u00e3o utilizada para definir uma fun\u00e7\u00e3o ass\u00edncrona.</li> <li><code>await</code>: express\u00e3o com sentido literal (aguarde). </li> <li><code>gather</code>: m\u00e9todo que executa tasks de forma concorrente.</li> <li><code>to_thread</code>: m\u00e9todo que executa uma task em uma thread separada.</li> </ul> <p>No <code>if __name__ == '__main__'</code> \u00e9 inserido apenas a execu\u00e7\u00e3o da fun\u00e7\u00e3o ass\u00edncrona <code>main()</code> atrav\u00e9s do m\u00e9todo <code>run()</code>.</p> <p>O siclo se reinicia a cada 10 segundos (Isso ocorre visando a queda do servi\u00e7o  na hora da emiss\u00e3o, ou seja, dez segundos \u00e9 tempo suficiente para cair e subir  o servi\u00e7o antes do envio do cupom para a SEFAZ).</p>"},{"location":"scripts_python/check_async/#codigo-completo","title":"C\u00f3digo completo","text":"check_async.py<pre><code>#!/usr/bin/env python3.9\n\nimport subprocess\nfrom asyncio import run, sleep, gather, to_thread\nfrom psutil import process_iter\nfrom constant import COMUNICADOR, MONITOR\n\n\ndef up_down(process):\n\"\"\"\n    Fun\u00e7\u00e3o respons\u00e1vel por identificar se o processo em palta est\u00e1 em execu\u00e7\u00e3o.\n    \"\"\"\n    for key, value in process.items():\n        for processo in process_iter(['name']):\n            if processo.info['name'] == key:\n                return True\n        subprocess.run(value, shell=True)\n\n\nasync def main():\n\"\"\"\n    Fun\u00e7\u00e3o principal que executa as verifica\u00e7\u00f5es/execu\u00e7\u00f5es como concorr\u00eancias.\n    \"\"\"\n    while True:\n        await gather(\n            to_thread(up_down, MONITOR),\n            to_thread(up_down, COMUNICADOR)\n            )\n        await sleep(10)\n\n\nif __name__ == '__main__':\n    run(main())\n</code></pre>"},{"location":"scripts_python/check_comunicador/","title":"Check Comunicador","text":"<p>Script python para checagem e verifica\u00e7\u00e3o de atividade para o Software monitor e comunicador da SEFAZ</p>"},{"location":"scripts_python/check_comunicador/#o-problema","title":"O problema","text":"<p>Inicialmente tivemos um problema relacionado aos drives do MFE (M\u00f3dulo Fiscal Eletr\u00f4nico) onde o mesmo ficava constantemente offline devido a queda dos servi\u00e7os do comunicador e monitor, por\u00e9m, os mesmos ficavam up com a execu\u00e7\u00e3o manual via shell.</p> <p>O script do comunicador \u00e9 respons\u00e1vel por estabelecer a comunica\u00e7\u00e3o do o MFE e o script monitor \u00e9 respons\u00e1vel por retornar um status visual do estado do m\u00f3dulo, ou seja, se encontra-se conectado ou n\u00e3o ao computador.</p>"},{"location":"scripts_python/check_comunicador/#solucao","title":"Solu\u00e7\u00e3o","text":"<p>Como solu\u00e7\u00e3o, trouxe um script em python onde o mesmo teria duas vers\u00f5es visando a falta de padroniza\u00e7\u00e3o nos sistemas linux (como ubuntu 16.04 e 18.04, Zorin 14.04 e 16.04).</p> <p>Nesse artigo trataremos do script adaptado como Solu\u00e7\u00e3o para o python3.6.</p> <p>A solu\u00e7\u00e3o abordada foi o script <code>check_comunicador.py</code>, que basicamente utiliza bibliotecas como threading, subprocess e time:</p> <ul> <li> <p>Threading: Utilizar threads possibilitou o a cria\u00e7\u00e3o de treads para ent\u00e3o   realizarmos a checagem de modo concorrente ao inserirmos na pool.</p> </li> <li> <p>Subprocess: A biblioteca subprocess \u00e9 utilizada para realizar processos   UNIX no python (como o up dos scripts que s\u00e3o feitos em shell).</p> </li> <li> <p>Time: Utilizada apenas para definir o time de rechecagem.</p> </li> </ul> check_comunicador.py<pre><code>import threading as t\nfrom subprocess import run, PIPE\nfrom time import sleep \n</code></pre> <p>Essa abordagem utiliza threads para execu\u00e7\u00e3o em paralelo visando a limita\u00e7\u00e3o do consumo de mem\u00f3ria ao impedir a cria\u00e7\u00e3o de processos \u00f3rf\u00e3os, visto que o mesmo seria executado via loop a cada dez segundos.</p>"},{"location":"scripts_python/check_comunicador/#analise-por-trecho-de-codigo","title":"An\u00e1lise por trecho de c\u00f3digo","text":"<p>De in\u00edcio temos a fun\u00e7\u00e3o <code>check_up()</code> que como o nome sugere, verifica se o script est\u00e1 up e retorna ou n\u00e3o o seu PID (N\u00famero do processo UNIX), caso o servi\u00e7o n\u00e3o esteja up o retorno \u00e9 uma string vazia.</p> <p>Outro ponto \u00e9 que essa fun\u00e7\u00e3o toma como par\u00e2metro apenas o servi\u00e7o <code>Comunicador</code> para verifica\u00e7\u00e3o de atividade. Essa medida foi tomada pois, as distros antigas est\u00e3o em processo de atualiza\u00e7\u00e3o, e tamb\u00e9m os erros dificilmente ocorrem com o servi\u00e7o do monitor (Ambas as verifica\u00e7\u00f5es s\u00e3o abordadas e realizadas no script <code>check_async.py</code>).</p> check_comunicador.py<pre><code>def check_up():\n\"\"\"\n    Fun\u00e7\u00e3o simples para coletar e retornar o PID do programa Comunicador.\n    \"\"\"\n\n    command = run(['ps -C Comunicador -o pid|grep -v PID'],\n                  shell=True,\n                  stdout=PIPE,\n                  universal_newlines=True)\n\n    return command.stdout.strip()\n</code></pre> <p>Como sequ\u00eancia temos a fun\u00e7\u00e3o <code>up</code> que de fato ir\u00e1 realizar o start dos programas repassados.</p> <p>De in\u00edcio temos duas constantes que ir\u00e3o armazenar a localiza\u00e7\u00e3o dos scripts: <code>COM</code> E <code>MON</code>.</p> <ul> <li>COM: Vari\u00e1vel com localiza\u00e7\u00e3o do script de start para o comunicador.</li> <li>MON: Vari\u00e1vel com localiza\u00e7\u00e3o do script de start para o Monitor.</li> </ul> check_comunicador.py<pre><code>COM = ['/usr/bin/nohup /opt/sefaz/cco/bin/runcco-ser.sh &gt; /dev/null 2&gt;&amp;1 &amp;']\nMON = ['/usr/bin/nohup /opt/sefaz/cco/bin/runcco-mon.sh &gt; /dev/null 2&gt;&amp;1 &amp;']\n</code></pre> <p>Em seguida veremos duas list comprehensions, onde a primeira far\u00e1 um for em cada objeto threading instanciado na vari\u00e1vel <code>threads</code> realizando assim um up na thread e por sua vez disponibilizando para a pool de processos e a segunda ir\u00e1 realizar um join em cada objeto threading, com isso o processo s\u00f3 ir\u00e1 avan\u00e7ar quando ambas as threads forem finalizadas. </p> check_comunicador.py<pre><code>def up():\n\"\"\"\n    Fun\u00e7\u00e3o que executa o script que chama o Comunicador em background e\n    redireciona sua sa\u00eddas para /dev/null quando executada atrav\u00e9s de uma thread\n    para limitar o consumo de mem\u00f3ria.\n    \"\"\"\n\n    COM = ['/usr/bin/nohup /opt/sefaz/cco/bin/runcco-ser.sh &gt; /dev/null 2&gt;&amp;1 &amp;']\n    MON = ['/usr/bin/nohup /opt/sefaz/cco/bin/runcco-mon.sh &gt; /dev/null 2&gt;&amp;1 &amp;']\n\n\n    threads = [\n        t.Thread(target=run(COM, shell=True), name='up'),\n        t.Thread(target=run(MON, shell=True), name='up')\n    ]\n\n    [th.start() for th in threads] \n    [th.join() for th in threads]\n</code></pre> <p>No <code>if __name__ == '__main__'</code> \u00e9 inserido um loop onde caso o servi\u00e7o n\u00e3o esteja rodando, a fun\u00e7\u00e3o <code>up()</code> ser\u00e1 chamada. O siclo se reinicia a cada 10 segundos (Isso ocorre visando a queda do servi\u00e7o na hora da emiss\u00e3o, ou seja, dez segundos \u00e9 tempo suficiente para cair e subir o servi\u00e7o antes do envio do cupom para a SEFAZ). </p> check_comunicador.py<pre><code>if __name__ == '__main__':\n\n    # O stdout do check_up(), ou seja, o output do run executado sempre ser\u00e1\n    # em string, se o comunicador n\u00e3o estiver em execu\u00e7\u00e3o o run() retornar\u00e1\n    # um string vazia, caso contr\u00e1rio o retorno ser\u00e1 uma string com o PID do\n    # processo.\n\n    # Loop que verifica se o Comunicador est\u00e1 UP\n    while True:\n        if not check_up():\n            up()\n\n        sleep(10)\n</code></pre>"},{"location":"scripts_python/check_comunicador/#codigo-completo","title":"C\u00f3digo completo","text":"check_comunicador.py<pre><code>#!/usr/bin/python3\n\nimport threading as t\nfrom subprocess import run, PIPE\nfrom time import sleep \n\n\ndef check_up():\n\"\"\"\n    Fun\u00e7\u00e3o simples para coletar e retornar o PID do programa Comunicador.\n    \"\"\"\n\n    command = run(['ps -C Comunicador -o pid|grep -v PID'],\n                  shell=True,\n                  stdout=PIPE,\n                  universal_newlines=True)\n\n    return command.stdout.strip()\n\n\ndef up():\n\"\"\"\n    Fun\u00e7\u00e3o que executa o script que chama o Comunicador em background e\n    redireciona sua sa\u00eddas para /dev/null quando executada atrav\u00e9s de uma thread\n    para limitar o consumo de mem\u00f3ria.\n    \"\"\"\n\n    COM = ['/usr/bin/nohup /opt/sefaz/cco/bin/runcco-ser.sh &gt; /dev/null 2&gt;&amp;1 &amp;']\n    MON = ['/usr/bin/nohup /opt/sefaz/cco/bin/runcco-mon.sh &gt; /dev/null 2&gt;&amp;1 &amp;']\n\n\n    threads = [\n        t.Thread(target=run(COM, shell=True), name='up'),\n        t.Thread(target=run(MON, shell=True), name='up')\n    ]\n\n    [th.start() for th in threads] \n    [th.join() for th in threads]\n\n\n\nif __name__ == '__main__':\n\n    # O stdout do check_up(), ou seja, o output do run executado sempre ser\u00e1\n    # em string, se o comunicador n\u00e3o estiver em execu\u00e7\u00e3o o run() retornar\u00e1\n    # um string vazia, caso contr\u00e1rio o retorno ser\u00e1 uma string com o PID do\n    # processo.\n\n    # Loop que verifica se o Comunicador est\u00e1 UP\n    while True:\n        if not check_up():\n            up()\n\n        sleep(10)\n</code></pre>"}]}